## 杂记
围绕redis常说的有三个点：
- 缓存击穿
> 其含义为，某一段数据在缓存中没有，在数据库中也没有，进而请求会直接裸奔式的打向数据库。
> 解决方案：缓存通常比数据库更抗压，响应速度越快，一般来说方案有两种，第一种是向缓存中设置空值，但是这种处理方式有几个弊端。第一，如果有大量不存在的数据直接设置到缓存中的话会把redis干爆。
> 第二，如果数据库中只是再请求的那一刻恰好没有值，但是后期又有值，那么如果一律设置为空值则会影响业务逻辑处理。因而就第一种方案而言，需要设置合理的过期时间，同时在代码设计上还可以考虑到
> 诸如限流、频控等处理。

> 第二种方案呢，就是在缓存之前再加一道【布隆过滤】处理，经过这道处理如果发现数据没有那么数据一定是没有的，如果说判断数据有那可能真实情况下不一定会有，因而这种实际也还是会出现少量的缓存击穿。

- 缓存雪崩
> 一般提到这个会涉及两点：1.redis服务器直接挂了。这种的话危害比较大，所以正常来说redis会做集群、做哨兵等等。2. 同一时间有大量缓存失效，这种的话解决方案也比较简单，为key设置不同的过期时间。

- 缓存穿透
> 这个其实是和缓存雪崩有一点关联的，缓存穿透主要涉及到的是热点key过期的一个问题，其实际现象就是缓存中没有数据库中有，于是乎大量请求打到数据库，很有可能将数据库干爆。
> 那么要解决这个问题实际就是尽早地恢复热点缓存或者将过期时间尽可能设置长一些，其中如果要恢复热点缓存的话无可规避的一个问题就是同一时间可能有大量请求都查缓存然后都没有查到数据，
> 那么要进行恢复的话不可能每次处理一个请求就更新一次，这样还是会有不少请求会直接请求数据库，因而这里需要控制只有一个线程也即一次请求可以设置缓存，也就是需要对这一过程加锁，
> 但是如果加锁就会导致大量请求被阻塞住，所以这种虽然也可以达到效果，但是也是会有隐患的。说回另外一点：让过期时间尽可能长，但实际上多长并不好控制，因而实际在处理过程中引入逻辑
> 过期的概念，也就是真实key其实不会过期，但是有逻辑过期字段，类似于逻辑删除，来标识这个缓存是否是已经过期了的。如果加了这个处理之后缓存中是会值的，此时如果有大量请求进入，
> 优先会取旧的缓存(这里之所以说旧的缓存，是因为它可能已经逻辑过期了，且这部分热点key是会被直接初始化到缓存中去)，如果发现过期了则会加【互斥锁】另开线程更新缓存值，但是这种处理
> 方式的缺点也显而易见，缓存与数据库不是实时的。
> 总的来说一致性和可用性是很难同时满足的，在选取具体的解决方案之前要以实际业务优先，有处理的侧重点。

